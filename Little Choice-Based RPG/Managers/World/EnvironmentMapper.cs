using Little_Choice_Based_RPG.Resources.Entities.Conceptual;
using Little_Choice_Based_RPG.Resources.Rooms;
using Little_Choice_Based_RPG.Resources.Systems.ContainerSystems.Inventory.InventoryExtensions;
using Little_Choice_Based_RPG.Resources.Systems.RoomSystems.DirectionExtensions;
using Little_Choice_Based_RPG.Types.Navigation;

namespace Little_Choice_Based_RPG.Managers.World
{
    /// <summary> Generates Rooms and the connections between them, cardinally. </summary>
    public static class EnvironmentMapper
    {
        /// <summary> Creates an interconnected 3D space of Rooms. Uses predefinedRooms where possible. Auto-generates new Rooms where needed. </summary>
        public static RoomPositions AutoGenerate(RoomPositions predefinedRooms, Coordinates minimumMapPoint, Coordinates maximumMapPoint)
        {
            RoomPositions currentEnvironment = new();
            RoomPositions remainingPredefinedRooms = new(predefinedRooms);

            //Iterate through each co-ordinate in the total map area
            for (int x = minimumMapPoint.X; x <= maximumMapPoint.X; x++)
            {
                for (int y = minimumMapPoint.Y; y <= maximumMapPoint.Y; y++)
                {
                    for (int z = maximumMapPoint.Z; z <= minimumMapPoint.Z; z++)
                    {
                        Coordinates location = new Coordinates(x, y, z);

                        //Fill the current coordinate and its nearby cardinal destination coordinates, too
                        FillAdjacentCardinals(location, minimumMapPoint, maximumMapPoint, currentEnvironment, predefinedRooms);

                        Room currentRoom = currentEnvironment.GetRoom(location);

                        //Link to cardinals and link in reverse! And fill the reversed for off-grids which are referenced already! :)
                        AddAllConnections(currentRoom, location, currentEnvironment, minimumMapPoint, maximumMapPoint);

                        //Now that the room has been added and connected, remove it from the list of remaining pre-defined Rooms.
                        remainingPredefinedRooms.Remove(location);
                    }
                }
            }

            //Link remaining off-grid destinations back to the off-grids.
            LinkOffGridDestinations(remainingPredefinedRooms, currentEnvironment, minimumMapPoint, maximumMapPoint);

            return currentEnvironment;
        }

        private static void FillCoordinate(Coordinates location, RoomPositions existingMap, RoomPositions predefinedRooms)
        {
            //If the Coordinate is not pre-defined...
            if (!predefinedRooms.HasCoordinates(location))
            {
                //If the existing coordinate is null, generate a new one. Mark it as auto-generated.
                if (!existingMap.HasCoordinates(location))
                    existingMap.Add(location, EnvironmentGeneration.GenerateRoom(location));

                //Otherwise, keep the existing one anyway :)
                return;
            }

            Room masterRoom = predefinedRooms.GetRoom(location);

            //If the existing coordinate is null...
            if (!existingMap.HasCoordinates(location))
            {
                //Generate a new room on the Coordinates. Mark it as auto-generated.
                existingMap.Add(location, masterRoom);
                return;
            }

            Room existingRoom = existingMap.GetRoom(location);

            //Skip, if the pre-defined room is already there
            if (existingRoom.Equals(masterRoom))
                return;

            //If autogenerated, make it null
            if (existingRoom.Properties.HasPropertyAndValue("DirectionSystem.Autogenerated", true))
                existingMap.Remove(location);

            //Existing coordinates should be null, now!
            if (existingMap.HasCoordinates(location))
                throw new Exception($"Tried to replace the Coordinate at X{location.X}, Y{location.Y}, Z{location.Z}, because a pre-defined Room wanted to go here... But there was already a unique room there, which didn't match!");

            //Add the predefined to the existing Map.
            existingMap.Add(location, masterRoom);
        }

        /// <summary> Fill the current coordinate and its nearby cardinal destination coordinates, too. </summary>
        private static void FillAdjacentCardinals(Coordinates absolute, Coordinates minimumMapPoint, Coordinates maximumMapPoint, RoomPositions existingMap, RoomPositions predefinedRooms)
        {
            //Test absolute is within the minimum and maximum axes:
            if (absolute.X < minimumMapPoint.X | absolute.X > maximumMapPoint.X)
                throw new Exception($"The absolute coordinate X: {absolute.X}, Y: {absolute.Y}, Z: {absolute.Z} was out of the map range along the X-axis!");
            
            if (absolute.Y < minimumMapPoint.Y | absolute.Y > maximumMapPoint.Y)
                throw new Exception($"The absolute coordinate X: {absolute.X}, Y: {absolute.Y}, Z: {absolute.Z} was out of the map range along the Y-axis!");

            if (absolute.Z < minimumMapPoint.Z | absolute.Z > maximumMapPoint.Z)
                throw new Exception($"The absolute coordinate X: {absolute.X}, Y: {absolute.Y}, Z: {absolute.Z} was out of the map range along the Z-axis!");


            //Generate nearby rooms, cardinally
            for (int xRelative = absolute.X - 1; xRelative <= (xRelative + 1); xRelative++)
            {
                if (xRelative < minimumMapPoint.X | xRelative > maximumMapPoint.X)
                    continue; //Skip if out of range

                for (int yRelative = absolute.Y - 1; yRelative <= (yRelative + 1); yRelative++)
                {
                    if (yRelative < minimumMapPoint.Y | yRelative > maximumMapPoint.Y)
                        continue; //Skip if out of range

                    for (int zRelative = absolute.Z - 1; zRelative <= (zRelative + 1); zRelative++)
                    {
                        if (yRelative < minimumMapPoint.Z | yRelative > maximumMapPoint.Z)
                            continue; //Skip if out of range

                        FillCoordinate(new Coordinates(xRelative, yRelative, zRelative), existingMap, predefinedRooms);
                    }
                }
            }
        }

        /// <summary> Link to cardinals and link in reverse! And fill reverse connections for off-grids declared here! :) </summary>
        private static void AddAllConnections(Room sourceLocation, Coordinates? sourceCoordinates, RoomPositions currentEnvironment, Coordinates minimumMapPoint, Coordinates maximumMapPoint)
        {
            if (!sourceLocation.Extensions.Contains("RoomConnections"))
                throw new Exception($"Tried to get a RoomConnections extension, but the target room {sourceLocation} didn't have a RoomConnections extension! Every room should have been initialised with one!");

            List<RoomConnection> connections = ((RoomConnections)sourceLocation.Extensions.Get("RoomConnections")).LocalConnections;

            //Link in reverse the target's initial Room Connections, which implicitly covers any off-grid connections declared on this Room!
            foreach (var connection in connections)
            {
                LinkConnection(connection, currentEnvironment, minimumMapPoint, maximumMapPoint);
            }

            //Check whether the target room is off-grid and therefore doesnt use the coordinate system
            if (sourceCoordinates is not Coordinates absolute) //Null check
                return; //Break, as the rest of the code is to do with the cardinal directions.

            //If it sits on the co-ordinate system, try to fill cardinals
            string[] cardinals = Enum.GetNames(typeof(CardinalDirection));

            //Process each cardinal
            foreach (var direction in cardinals)
            {
                int targetX = absolute.X;
                int targetY = absolute.Y;
                int targetZ = absolute.Z;
                Enum.TryParse(direction, out CardinalDirection cardinal);

                if (direction.Contains("East")) targetX++;
                else if (direction.Contains("West")) targetX--;

                if (direction.Contains("Up")) targetY++;
                else if (direction.Contains("Down")) targetY--;

                if (direction.Contains("North")) targetZ--;
                else if (direction.Contains("South")) targetZ++;

                Coordinates targetCoordinates = new Coordinates(targetX, targetY, targetZ);
                Room destinationLocation = currentEnvironment.GetRoom(targetCoordinates);

                RoomConnections sourceConnections = ((RoomConnections)sourceLocation.Extensions.Get("RoomConnections"));
                RoomConnections destinationConnections = ((RoomConnections)destinationLocation.Extensions.Get("RoomConnections"));
                RoomConnection? possibleSourceConnection;


                //Ensure the destination is a valid coordinate within the map limits.
                    //Test absolute is within the minimum and maximum axes:
                    if (targetCoordinates.X < minimumMapPoint.X | targetCoordinates.X > maximumMapPoint.X)
                        continue; //Continue to next co-ordinate. Out of bounds, X-axis

                    if (targetCoordinates.Y < minimumMapPoint.Y | targetCoordinates.Y > maximumMapPoint.Y)
                        continue; //Continue to next co-ordinate. Out of bounds, Y-axis

                    if (targetCoordinates.Z < minimumMapPoint.Z | targetCoordinates.Z > maximumMapPoint.Z)
                        continue; //Continue to next co-ordinate. Out of bounds, Z-axis


                //If a connection between the two co-ordinates already exists
                if (sourceConnections.LocalConnections.Any(i => i.Source == sourceLocation && i.Destination == destinationLocation))
                {
                    //Grab it
                    possibleSourceConnection = sourceConnections.LocalConnections.Find(i => i.Source == sourceLocation && i.Destination == destinationLocation);

                    //Ensure that the cardinal direction isn't already handled by a non-cardinal destination. If it is, turn the non-cardinal destination into a cardinal.
                    if (possibleSourceConnection is RoomConnection existingSourceConnection && existingSourceConnection.Direction is null)
                    {
                        //Generate a new connection to replace
                        RoomConnection replacementSourceConnection = new(existingSourceConnection.Source, existingSourceConnection.Destination, cardinal, existingSourceConnection.AssociatedObject);
                        RoomConnection replacementDestinationConnection = new(existingSourceConnection.Destination, existingSourceConnection.Source, cardinal, existingSourceConnection.AssociatedObject);


                        //Try to grab the destination connection, too
                        RoomConnection? possibleDestinationConnection = null;

                        if (destinationConnections.LocalConnections.Any(i => i.Source == destinationLocation && i.Destination == sourceLocation))
                            possibleDestinationConnection = destinationConnections.LocalConnections.Find(i => i.Source == destinationLocation && i.Destination == sourceLocation);


                        //Remove from both, if they're there
                        sourceConnections.LocalConnections.Remove(existingSourceConnection);

                        if (possibleDestinationConnection is RoomConnection existingDestinationConnection)
                            if (destinationConnections.LocalConnections.Contains(existingDestinationConnection))
                                destinationConnections.LocalConnections.Remove(existingDestinationConnection);


                        //Update the non-cardinals to their new cardinal
                        sourceConnections.LocalConnections.Add(replacementSourceConnection);
                        destinationConnections.LocalConnections.Add(replacementDestinationConnection);
                    }
                }
                else //If it doesn't exist, generate a new one anyway.
                {
                    //Generate the missing cardinal connections
                    RoomConnection newSourceConnection = new(sourceLocation, destinationLocation, cardinal, null);
                    RoomConnection newDestinationConnection = new(destinationLocation, sourceLocation, cardinal, null);

                    //Add in the new cardinal connections
                    sourceConnections.LocalConnections.Add(newSourceConnection);
                    destinationConnections.LocalConnections.Add(newDestinationConnection);
                }
            }
        }

        /// <summary> Link off-grid destinations back to the off-grids. </summary>
        private static void LinkOffGridDestinations(RoomPositions remainingPredefinedRooms, RoomPositions currentEnvironment, Coordinates minimumMapPoint, Coordinates maximumMapPoint)
        {
            foreach (var targetRoom in remainingPredefinedRooms)
            {
                //Verify that this is off grid and not just out of bounds.
                if (targetRoom.RoomCoordinates is not null)
                    continue; //Skip if on-grid

                if (!targetRoom.RoomRef.Extensions.Contains("RoomConnections"))
                    throw new Exception($"Tried to get a RoomConnections extension, but the target room {targetRoom} didn't have a RoomConnections extension! Every room should have been initialised with one!");

                List<RoomConnection> targetConnections = ((RoomConnections)targetRoom.RoomRef.Extensions.Get("RoomConnections")).LocalConnections;

                //Add the reverse for any connections to points within the valid map area. 
                foreach (var targetConnection in targetConnections)
                {
                    LinkConnection(targetConnection, currentEnvironment, minimumMapPoint, maximumMapPoint);
                }
            }
        }


        private static void LinkConnection(RoomConnection targetConnection, RoomPositions currentEnvironment, Coordinates minimumMapPoint, Coordinates maximumMapPoint)
        {
            if (!targetConnection.Destination.Extensions.Contains("RoomConnections"))
                throw new Exception($"Tried to get a RoomConnections extension, but the target room {targetConnection.Destination} didn't have a RoomConnections extension! Every room should have been initialised with one!");

            Room destinationRoom = (Room) targetConnection.Destination;
            //Ensure the destination is either a valid coordinate within the map limits, or off-grid instead.
            Coordinates ? destinationLocation = currentEnvironment.GetCoordinates(destinationRoom);

            if (destinationLocation is Coordinates destinationAbsolute) //Skip this block if null (off-grid)
            {
                //Test absolute is within the minimum and maximum axes:
                if (destinationAbsolute.X < minimumMapPoint.X | destinationAbsolute.X > maximumMapPoint.X)
                    return; //Out of bounds, X-axis

                if (destinationAbsolute.Y < minimumMapPoint.Y | destinationAbsolute.Y > maximumMapPoint.Y)
                    return; //Out of bounds, Y-axis

                if (destinationAbsolute.Z < minimumMapPoint.Z | destinationAbsolute.Z > maximumMapPoint.Z)
                    return; //Out of bounds, Z-axis
            }

            List<RoomConnection> destinationConnections = ((RoomConnections)destinationRoom.Extensions.Get("RoomConnections")).LocalConnections;

            //Check whether the destination already has a room connection leading here, via the associated object
            if (destinationConnections.Any(i => (i.Destination == targetConnection.Source) && (i.AssociatedObject == targetConnection.AssociatedObject)))
            {
                RoomConnection destinationConnection = destinationConnections.Find(i => (i.Destination == targetConnection.Source) && (i.AssociatedObject == targetConnection.AssociatedObject));

                //Validate that their states match
                if (destinationConnection.IsVisible != targetConnection.IsVisible)
                    throw new Exception("The RoomConnections either side of the same connection, referenced the same object, but their IsVisible value was somehow out of sync!");
            }
            else
            {
                //Add a new one.
                destinationConnections.Add(new RoomConnection(targetConnection.Destination, targetConnection.Source, null, targetConnection.AssociatedObject));
            }


            //Share the associated object, if there is one, and if it doesnt already exist in both rooms' inventories.
            if (targetConnection.AssociatedObject is not null)
            {
                List<GameObject> sourceInventory =
                    ((ItemContainer)targetConnection
                        .Source
                        .Extensions
                        .Get("ItemContainer"))
                        .Inventory;

                List<GameObject> destinationInventory =
                    ((ItemContainer)targetConnection
                        .Destination
                        .Extensions
                        .Get("ItemContainer"))
                        .Inventory;

                if (!sourceInventory.Contains(targetConnection.AssociatedObject))
                    sourceInventory.Add(targetConnection.AssociatedObject);

                if (!destinationInventory.Contains(targetConnection.AssociatedObject))
                    destinationInventory.Add(targetConnection.AssociatedObject);

                //Ensure they represent eachother using the extendImmobile system
                implementmeplease:)
            }
        }
    }
}